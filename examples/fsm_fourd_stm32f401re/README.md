# LSM6DSV80X Sensor Data Acquisition on STM32F401RE with IKS4A1 Shield (UCF-Configured FSM Events)

Simple example of 4D position recognition typically used in smartphone devices. The example uses the accelerometer X and Y axes to determine portrait (up or down) and landscape (left or right) orientation.

This project demonstrates how to interface the **LSM6DSV80X** inertial measurement unit (IMU) sensor with an **STM32F401RE** microcontroller board using the **IKS4A1** sensor shield. The program reads accelerometer, gyroscope, and temperature data from the sensor via I2C, processes finite state machine (FSM) events configured via UCF files, and outputs event notifications over UART.

The code is written in Rust using the `stm32f4xx-hal` hardware abstraction layer and the `lsm6dsv80x` sensor driver crate. It leverages the **`ucf-tool`** to generate Rust code at build time from UCF (Universal Configuration File) sensor configuration files, enabling flexible sensor FSM configuration.

---

## Hardware Setup

- **Microcontroller Board:** STM32F401RE Nucleo-64
- **Sensor Shield:** IKS4A1 (STMicroelectronics sensor expansion board)
- **Sensor:** LSM6DSV80X IMU (accelerometer + gyroscope + FSM-based event detection)
- **Communication Interface:** I2C (100 kHz Standard Mode)
- **UART:** USART2 for serial output at 115200 baud
- **Interrupt Pin:** PC0 configured as input with external interrupt for FSM event notification

### Default Pin Configuration

| Signal       | STM32F401RE Pin | IKS4A1 Shield Pin | Description                  |
|--------------|-----------------|-------------------|------------------------------|
| I2C1_SCL     | PB8             | SCL               | I2C clock line (open-drain)  |
| I2C1_SDA     | PB9             | SDA               | I2C data line (open-drain)   |
| USART2_TX    | PA2             | UART TX           | UART transmit for debug output|
| EXTI0 (INT)  | PC0             | INT1 (FSM event)  | External interrupt from sensor FSM event |

The IKS4A1 shield is mounted on top of the STM32F401RE Nucleo board, connecting the LSM6DSV80X sensor to the microcontroller's I2C1 peripheral on pins PB8 (SCL) and PB9 (SDA). The sensor's FSM event interrupt line is connected to PC0, configured to trigger an external interrupt on rising edge. UART output is routed through PA2 for serial communication.

---

## Code Description

The configuration runs at 30 Hz.

### Initialization

- The program initializes microcontroller peripherals, including clocks, GPIO pins, I2C, and UART.
- The I2C bus is configured for 100 kHz Standard Mode with open-drain pins PB8 and PB9.
- UART is configured on PA2 at 115200 baud for serial output.
- PC0 is configured as an input pin and set up to generate an interrupt on rising edge.
- The external interrupt line is enabled in the NVIC and linked to the EXTI0 interrupt handler.
- A global mutex-protected static holds the interrupt pin to clear interrupt flags safely.

### Sensor Setup via UCF Configuration

- The LSM6DSV80X sensor is initialized over I2C.
- The device ID is read and verified to confirm sensor presence.
- The sensor is reset to default configuration and waits until reset completes.
- The sensor is configured by applying a sequence of register writes and delays generated by the **`ucf-tool`** from a UCF file (`lsm6dsv80x_four_d.ucf`), which programs the sensor's FSM for gesture detection.
- This approach allows flexible and maintainable sensor configuration by editing UCF files and regenerating Rust code at build time.

### Data Acquisition Loop

- The main loop waits for interrupts signaling FSM events.
- When an interrupt occurs, the program reads the sensor's FSM event status.
- If FSM1 event is detected, it reads the FSM output and matches known event codes:
  - `0x10` indicates a "Y down" event.
  - `0x20` indicates a "Y up" event.
  - `0x40` indicates an "X down" event.
  - `0x80` indicates an "X up" event.
- Detected events are printed over UART for monitoring.

### Interrupt Handler

- The `EXTI0` interrupt handler clears the interrupt pending bit on PC0 to allow further interrupts.

---

## Usage

1. Connect the IKS4A1 shield to the STM32F401RE Nucleo board.
2. Connect the sensor's FSM interrupt line to PC0 on the STM32F401RE.
3. Build the project, which uses the **`ucf-tool`** to generate Rust configuration code from UCF files automatically at build time.
4. Flash the compiled Rust firmware onto the STM32F401RE.
5. Open a serial terminal at 115200 baud on the UART port.
6. Perform gestures or movements that trigger FSM events.
7. Observe event notifications printed over UART.

---

## Notes

- This example uses polling of interrupts and FSM event registers for gesture detection.
- The **`ucf-tool`** enables flexible sensor FSM configuration by converting UCF files into Rust code.
- The sensor driver and UCF-generated code handle low-level register access and FSM programming.
- The environment is `#![no_std]` and `#![no_main]` for embedded Rust applications.
- Panic behavior is set to halt on panic (`panic_halt`).
- ENU orientation is required.

---

## References

- [STM32F401RE Nucleo-64 Board](https://www.st.com/en/evaluation-tools/nucleo-f401re.html)
- [IKS4A1 Sensor Shield](https://www.st.com/en/ecosystems/x-nucleo-iks4a1.html)
- [LSM6DSV80X Datasheet](https://www.st.com/resource/en/datasheet/lsm6dsv80x.pdf)
- [stm32f4xx-hal Rust crate](https://docs.rs/stm32f4xx-hal)

---

*This README provides a detailed explanation of the embedded Rust program for FSM-based gesture detection on STM32F401RE with the IKS4A1 shield, leveraging UCF-generated configuration code.*
